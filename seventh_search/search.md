#### 7. 查找

***

* **查找表**（search table）是由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵便的数据结构。
* 对查找表经常进行的操作有：
  * 查询某个“特定的”数据元素是够在查找表中；
  * 检索某个”特定的“数据元素的各种属性；
  * 在查找表中插入一个数据元素；
  * 从查找表中删去某个数据元素。
* 若对查找表只作前两种统称为“查找”的操作，则称此类查找表为**静态查找表**（Static Search Table）。若在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某个数据元素，则称此类表为**动态查找表**（Dynamic Search Table）。
* **关键字**（Key）是数据元素（或记录）中某个数据项的值，用它可以标识（识别）一个数据元素（或记录）。若此关键字可以惟一地标识一个记录，则称此关键字为**主关键字**（Primary Key）（对不同的记录，其主关键字均不同）。反之，称用以识别若干记录的关键字为**次关键字**（Secondary Key）。当数据元素值有一个数据项时，其关键字即为该数据元素的值。
* **查找**（Searching）是根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称**查找**是**成功**的，此时查找的结果为给出整个记录的信息，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称**查找不成功**，此时查找的结果可给出一个“空“记录或”空“指针。

```c++
//典型的关键字类型说明可以是
typedef float KeyType //实型
typedef int KeyType //整型
typedef char *KeyType //字符串型

//数据元素类型定义为
typedef struct
{
    KeyType key; //关键字域
    ... //其他域
}SElemType;

//对两个关键字的比较约定为如下的宏定义
//对数值型关键字
#define EQ(a, b) ((a) == (b))
#define LT(a, b) ((a) < (b))
#define LQ(a, b) ((a) <= (b))
...
    
//对字符串型关键字
#define EQ(a, b) (!strcmp((a), (b)))
#define LT(a, b) (strcmp((a), (b)) < 0)
#define LQ(a, b) (strcmp((a), (b)) <= 0)
...
```
***
1. 静态查找表


```c++
//静态查找表的定义
ADT StaticSearchTable
{
    数据对象：
    数据关系：
    基本操作：
        Creat(&ST, n);
    	Destroy(&ST);
    	Search(ST, Key);
    	Traverse(ST, Visit());
}ADT StaticSearchTable
```

* [**顺序查找**](https://github.com/fantasia85/data-structure/blob/master/seventh_search/search/StaticSearchTable/search_seq.cpp)（Sequential Search）的查找过程为：从表中最后一个记录开始，逐个进行记录的关键字和给定值的比较，若某个记录的关键字和给定值比较相等，则查找成功，找到所查记录；反之，若直至第一个记录，其关键字和给定值比较都不等，则表明表中没有所查记录，查找不成功。

* 为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值称为查找算法在查找成功时的**平均查找长度**（Average Search Length）。

* 对于含有n个记录的表，查找成功时的平均查找长度
  $$
  ASL=\sum_{i=1}^n\mathtt{P}_i\mathtt{C}_i
  $$
  其中*P<sub>i</sub>*为查找表中第*i*个记录的概率，*c<sub>i</sub>*为找到表中其关键字与给定值相等的第i个记录时，和给定值已进行过比较的关键字个数。
  
* 顺序查找在等概率情况下，查找平均长度为（n+1）/2，查找不成功平均长度为（n+1）。
  
* 有序表的查找：[**折半查找**](https://github.com/fantasia85/data-structure/blob/master/seventh_search/search/StaticSearchTable/search_bin.cpp)（Binary Search）的查找过程是：先确定待查记录所在的范围（区间），然后逐步缩小范围直到找到或找不到该记录为止。
  
* 折半查找的过程可用二叉树来描述。树中的每个结点表示表中一个记录，结点中的值为该记录在表中的位置，通常称这个描述查找过程的二叉树为判定树。和给定值进行比较的关键字个数为该路径上的结点树或结点在判定树上的层次数。
  
* 折半查找在查找成功时和给定值进行比较的关键字个数至多为*𠃊log<sub>2</sub>n𠃎+1*，折半查找不成功时和给定值进行比较的关键字个数也不超过*𠃊log<sub>2</sub>n𠃎+1*。
  
* 折半查找的平均查找长度为*𠃊log<sub>2</sub>(n+1)𠃎-1*。折半查找的效率比顺序查找高，但折半查找只适用于有序表，且限于顺序存储结构（对线性链表无法有效地进行折半查找）。
  
* 以有序表表示静态查找表时，进行查找的方法除了折半查找之外，还有斐波那契查找和插值查找。
  
* 索引顺序表的查找：若以索引顺序表表示静态查找表，则search函数可用分块查找来实现，分块查找又称索引顺序查找。在此查找法中，除表本身外，尚需建立一个“索引表”。对每个子表（或称块）建立一个索引项，其中包括两项内容：关键字项（其值为该子表内的最大关键字）和指针项（指示该子表的第一个记录在表中位置）。索引表按关键字有序，则表或者有序或者分块有序。

***
2. 动态查找表

* 动态查找表的特点是，表结构本身是在查找过程中动态生成的，即对于给定值key，若表中存在其关键字等于key的记录，则查找成功返回，否则插入关键字等于key的记录。

```c++
//抽象数据类型动态查找表的定义如下
ADT DynamicSearchTable
{
    数据对象：
    数据关系：
    基本操作：
        InitDSTable(&DT);
    	DestroyDSTable(&DT);
    	SearchDSTable(DT, key);
    	InsertDSTable(&DT, e);
    	DeleteDSTable(&DT, key);
    	TraverseDSTable(DV, Visit());
}ADT DynamicSearchTable
```

* [**二叉排序树**](https://github.com/fantasia85/data-structure/blob/master/seventh_search/search/DynamicSearchTable/BST.cpp)（Binary Sort Tree）或者是一棵空树；或者是具有下列性质的二叉树：
  * 若它的左子树不空，则左子树上**所有**结点的值**均小于**它的根结点的值；
  * 若它的右子树不空，则右子树上**所有**结点的值**均大于**它的根结点的值；
  * 它的左、右子树也分别为二叉排序树。
* 二叉排序树的插入：新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。
* 中序遍历二叉排序树可得到一个关键字的有序序列。
* 每次插入的新结点都是二叉排序树上新的叶子结点，则在进行插入操作时，不必移动其他结点，仅需改动某个结点的指针，由空变为非空即可。
* 二叉排序树的删除：假设在二叉排序树上被删结点为***p**（指向结点的指针为p），其双亲结点为***f**（结点指针为f），且不失一般性，可设***p**是***f**的左孩子。分三种情况讨论：
  * 若***p**结点为叶子结点，即左孩子和右孩子均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。
  * 若***p**结点只有左子树或者只有右子树，此时只要令左子树或右子树直接成为其双亲结点***f**的左子树即可。
  * 若***p**结点的左子树和右子树均不空。显然，此时不能如上简单处理。有两种做法：其一是令***p**的左子树为***f**的左子树，而***p**的右子树为***s**的右子树；其二是令***p**的直接前驱（或直接后继）替代***p**，然后再从二叉排序树中删去它的直接前驱（或直接后继）。
  * 直接前驱：左子树的最大值；直接后继：右子树的最小值。
* 在随机的情况下，二叉排序树的平均查找长度和log*n*是等数量级的。
* **平衡二叉树**（Balanced Binary Tree 或Height-Balanced Tree）又称AVL树。它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。若将二叉树上结点的**平衡因子**BF（Balance Factor）定义为该结点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有结点的平衡因子只可能是-1，0和1。
* 一般情况下，假设由于在二叉排序树上插入结点而失去平衡的最小子树根结点的指针为a（即a是离插入结点最近，且平衡因子绝对值超过1的祖先结点），则失去平衡后进行调整的规律可归纳为下列4种情况：
  1. 单项右旋平衡处理：由于在***a**的左子树根结点的左子树上插入结点，***a**的平衡因子由1增至2，致使以***a**为根的子树失去平衡，则需进行一次向右的顺时针旋转操作。
  2. 单项左旋平衡处理：由于在***a**的右子树根结点的右子树上插入结点，***a**的平衡因子由-1变为-2，致使以***a**为根结点的子树失去平衡，则需进行一次向右的逆时针旋转操作。
  3. 双向旋转（先左后右）平衡处理：由于在***a**的左子树根结点的右子树上插入结点，***a**的平衡因子由1增至2，致使以***a**为根结点的子树失去平衡，则需进行两次旋转（先左旋后右旋）操作。
  4. 双向旋转（先右后左）平衡处理：由于在***a**的右子树根结点的左子树上插入结点，***a**的平衡因子由-1变为-2，致使以***a**为根结点的子树失去平衡，则需进行两次旋转（先右旋后左旋）操作。
* 当平衡的二叉排序树因插入结点而失去平衡时，仅需对最小不平衡子树进行平衡旋转处理即可。
* 在平衡的二叉排序树BBST上插入一个新的数据元素e的递归算法可描述如下：
  * 若BBST为空树，则插入一个数据元素为e的新结点作为BBST的根结点，树的深度增1；
  * 若e的关键字和BBST的根结点的关键字相等，则不进行插入；
  * 若e的关键字小于BBST的根结点的关键字，而且在BBST的左子树中不存在和e有相同关键字的结点，则将e插入在BBST的左子树上，并且当插入之后的左子树深度增加（+1）时，分别就下列不同情况处理之：
    1. BBST的根结点的平衡因子为-1（右子树的深度大于左子树的深度）：则将根结点的平衡因子更改为0，BBST的深度不变；
    2. BBST的根结点的平衡因子为0（左、右子树的深度相等）：则将根结点的平衡因子更改为1，BBST的深度增1；
    3. BBST的根结点的平衡因子为1（左子树的深度大于右子树的深度）：若BBST的左子树根结点的平衡因子为1，则需进行单向右旋平衡处理，并且在右旋处理之后，将根结点和其右子树根结点的平衡因子更改为0，树的深度不变；若BBST的左子树根结点的平衡因子为-1，则需进行先向左、后向右的双向旋转平衡处理，并且在旋转处理之后，修改根结点和其左、右子树根结点的平衡因子，树的深度不变；
  * 若e的关键字大于BBST的根结点的关键字，而且在BBST的右子树中不存在和e有相同关键字的结点，则将e插入在BBST的右子树上，并且当插入之后的右子树深度增加（+1）时，分别就不同情况处理之。

```c++
//平衡二叉树的类型定义
typedef struct BSTNode
{
    ElemType data;
    int bf; //结点的平衡因子
    struct BSTNode *lchild, *rchild; //左、右孩子指针
}BSTNode, *BSTree;
```

* 在平衡树上进行查找的时间复杂度为*O(logn)*。