#### 7. 查找

***

* **查找表**（search table）是由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵便的数据结构。
* 对查找表经常进行的操作有：
  * 查询某个“特定的”数据元素是够在查找表中；
  * 检索某个”特定的“数据元素的各种属性；
  * 在查找表中插入一个数据元素；
  * 从查找表中删去某个数据元素。
* 若对查找表只作前两种统称为“查找”的操作，则称此类查找表为**静态查找表**（Static Search Table）。若在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某个数据元素，则称此类表为**动态查找表**（Dynamic Search Table）。
* **关键字**（Key）是数据元素（或记录）中某个数据项的值，用它可以标识（识别）一个数据元素（或记录）。若此关键字可以惟一地标识一个记录，则称此关键字为**主关键字**（Primary Key）（对不同的记录，其主关键字均不同）。反之，称用以识别若干记录的关键字为**次关键字**（Secondary Key）。当数据元素值有一个数据项时，其关键字即为该数据元素的值。
* **查找**（Searching）是根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称**查找**是**成功**的，此时查找的结果为给出整个记录的信息，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称**查找不成功**，此时查找的结果可给出一个“空“记录或”空“指针。

```c++
//典型的关键字类型说明可以是
typedef float KeyType //实型
typedef int KeyType //整型
typedef char *KeyType //字符串型

//数据元素类型定义为
typedef struct
{
    KeyType key; //关键字域
    ... //其他域
}SElemType;

//对两个关键字的比较约定为如下的宏定义
//对数值型关键字
#define EQ(a, b) ((a) == (b))
#define LT(a, b) ((a) < (b))
#define LQ(a, b) ((a) <= (b))
...
    
//对字符串型关键字
#define EQ(a, b) (!strcmp((a), (b)))
#define LT(a, b) (strcmp((a), (b)) < 0)
#define LQ(a, b) (strcmp((a), (b)) <= 0)
...
```
***
1. 静态查找表


```c++
//静态查找表的定义
ADT StaticSearchTable
{
    数据对象：
    数据关系：
    基本操作：
        Creat(&ST, n);
    	Destroy(&ST);
    	Search(ST, Key);
    	Traverse(ST, Visit());
}ADT StaticSearchTable
```

* [**顺序查找**](https://github.com/fantasia85/data-structure/blob/master/seventh_search/search/StaticSearchTable/search_seq.cpp)（Sequential Search）的查找过程为：从表中最后一个记录开始，逐个进行记录的关键字和给定值的比较，若某个记录的关键字和给定值比较相等，则查找成功，找到所查记录；反之，若直至第一个记录，其关键字和给定值比较都不等，则表明表中没有所查记录，查找不成功。

* 为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值称为查找算法在查找成功时的**平均查找长度**（Average Search Length）。

* 对于含有n个记录的表，查找成功时的平均查找长度
  $$
  ASL=\sum_{i=1}^n\mathtt{P}_i\mathtt{C}_i
  $$
  其中*Pi*为查找表中第*i*个记录的概率，*ci*为找到表中其关键字与给定值相等的第i个记录时，和给定值已进行过比较的关键字个数。
  
* 顺序查找在等概率情况下，查找平均长度为（n+1）/2，查找不成功平均长度为（n+1）。
  
* 有序表的查找：[**折半查找**](https://github.com/fantasia85/data-structure/blob/master/seventh_search/search/StaticSearchTable/search_bin.cpp)（Binary Search）的查找过程是：先确定待查记录所在的范围（区间），然后逐步缩小范围直到找到或找不到该记录为止。
  
* 折半查找的过程可用二叉树来描述。树中的每个结点表示表中一个记录，结点中的值为该记录在表中的位置，通常称这个描述查找过程的二叉树为判定树。和给定值进行比较的关键字个数为该路径上的结点树或结点在判定树上的层次数。
  
* 折半查找在查找成功时和给定值进行比较的关键字个数至多为*𠃊log2n𠃎+1*，折半查找不成功时和给定值进行比较的关键字个数也不超过*𠃊log2n𠃎+1*。
  
* 折半查找的平均查找长度为*𠃊log2(n+1)𠃎-1*。折半查找的效率比顺序查找高，但折半查找只适用于有序表，且限于顺序存储结构（对线性链表无法有效地进行折半查找）。
  
* 以有序表表示静态查找表时，进行查找的方法除了折半查找之外，还有斐波那契查找和插值查找。
  
* 索引顺序表的查找：若以索引顺序表表示静态查找表，则search函数可用分块查找来实现，分块查找又称索引顺序查找。在此查找法中，除表本身外，尚需建立一个“索引表”。对每个子表（或称块）建立一个索引项，其中包括两项内容：关键字项（其值为该子表内的最大关键字）和指针项（指示该子表的第一个记录在表中位置）。索引表按关键字有序，则表或者有序或者分块有序。

***
2. 动态查找表

* 动态查找表的特点是，表结构本身是在查找过程中动态生成的，即对于给定值key，若表中存在其关键字等于key的记录，则查找成功返回，否则插入关键字等于key的记录。

```c++
//抽象数据类型动态查找表的定义如下
ADT DynamicSearchTable
{
    数据对象：
    数据关系：
    基本操作：
        InitDSTable(&DT);
    	DestroyDSTable(&DT);
    	SearchDSTable(DT, key);
    	InsertDSTable(&DT, e);
    	DeleteDSTable(&DT, key);
    	TraverseDSTable(DV, Visit());
}ADT DynamicSearchTable
```

* **二叉排序树**（Binary Sort Tree）或者是一棵空树；或者是具有下列性质的二叉树：
  * 若它的左子树不空，则左子树上**所有**结点的值**均小于**它的根结点的值；
  * 若它的右子树不空，则右子树上**所有**结点的值**均大于**它的根结点的值；
  * 它的左、右子树也分别为二叉排序树。
* 二叉排序树的插入：新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。
* 中序遍历二叉排序树可得到一个关键字的有序序列。
* 

