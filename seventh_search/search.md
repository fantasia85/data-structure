#### 7. 查找

***

* **查找表**（search table）是由同一类型的数据元素（或记录）构成的集合。由于“集合”中的数据元素之间存在着完全松散的关系，因此查找表是一种非常灵便的数据结构。
* 对查找表经常进行的操作有：
  * 查询某个“特定的”数据元素是够在查找表中；
  * 检索某个”特定的“数据元素的各种属性；
  * 在查找表中插入一个数据元素；
  * 从查找表中删去某个数据元素。
* 若对查找表只作前两种统称为“查找”的操作，则称此类查找表为**静态查找表**（Static Search Table）。若在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已存在的某个数据元素，则称此类表为**动态查找表**（Dynamic Search Table）。
* **关键字**（Key）是数据元素（或记录）中某个数据项的值，用它可以标识（识别）一个数据元素（或记录）。若此关键字可以惟一地标识一个记录，则称此关键字为**主关键字**（Primary Key）（对不同的记录，其主关键字均不同）。反之，称用以识别若干记录的关键字为**次关键字**（Secondary Key）。当数据元素值有一个数据项时，其关键字即为该数据元素的值。
* **查找**（Searching）是根据给定的某个值，在查找表中确定一个其关键字等于给定值的记录或数据元素。若表中存在这样的一个记录，则称**查找**是**成功**的，此时查找的结果为给出整个记录的信息，或指示该记录在查找表中的位置；若表中不存在关键字等于给定值的记录，则称**查找不成功**，此时查找的结果可给出一个“空“记录或”空“指针。

```c++
//典型的关键字类型说明可以是
typedef float KeyType //实型
typedef int KeyType //整型
typedef char *KeyType //字符串型

//数据元素类型定义为
typedef struct
{
    KeyType key; //关键字域
    ... //其他域
}SElemType;

//对两个关键字的比较约定为如下的宏定义
//对数值型关键字
#define EQ(a, b) ((a) == (b))
#define LT(a, b) ((a) < (b))
#define LQ(a, b) ((a) <= (b))
...
    
//对字符串型关键字
#define EQ(a, b) (!strcmp((a), (b)))
#define LT(a, b) (strcmp((a), (b)) < 0)
#define LQ(a, b) (strcmp((a), (b)) <= 0)
...
```

***

1. 静态查找表


```c++
//静态查找表的定义
ADT StaticSearchTable
{
    数据对象：
    数据关系：
    基本操作：
        Creat(&ST, n);
    	Destroy(&ST);
    	Search(ST, Key);
    	Traverse(ST, Visit());
}ADT StaticSearchTable
```

* [**顺序查找**](https://github.com/fantasia85/data-structure/blob/master/seventh_search/search/StaticSearchTable/search_seq.cpp)（Sequential Search）的查找过程为：从表中最后一个记录开始，逐个进行记录的关键字和给定值的比较，若某个记录的关键字和给定值比较相等，则查找成功，找到所查记录；反之，若直至第一个记录，其关键字和给定值比较都不等，则表明表中没有所查记录，查找不成功。

* 为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值称为查找算法在查找成功时的**平均查找长度**（Average Search Length）。

* 对于含有n个记录的表，查找成功时的平均查找长度
  $$
  ASL=\sum_{i=1}^n\mathtt{P}_i\mathtt{C}_i
  $$
  其中*P<sub>i</sub>*为查找表中第*i*个记录的概率，*c<sub>i</sub>*为找到表中其关键字与给定值相等的第i个记录时，和给定值已进行过比较的关键字个数。

* 顺序查找在等概率情况下，查找平均长度为（n+1）/2，查找不成功平均长度为（n+1）。

* 有序表的查找：[**折半查找**](https://github.com/fantasia85/data-structure/blob/master/seventh_search/search/StaticSearchTable/search_bin.cpp)（Binary Search）的查找过程是：先确定待查记录所在的范围（区间），然后逐步缩小范围直到找到或找不到该记录为止。

* 折半查找的过程可用二叉树来描述。树中的每个结点表示表中一个记录，结点中的值为该记录在表中的位置，通常称这个描述查找过程的二叉树为判定树。和给定值进行比较的关键字个数为该路径上的结点树或结点在判定树上的层次数。

* 折半查找在查找成功时和给定值进行比较的关键字个数至多为*𠃊log<sub>2</sub>n𠃎+1*，折半查找不成功时和给定值进行比较的关键字个数也不超过*𠃊log<sub>2</sub>n𠃎+1*。

* 折半查找的平均查找长度为*𠃊log<sub>2</sub>(n+1)𠃎-1*。折半查找的效率比顺序查找高，但折半查找只适用于有序表，且限于顺序存储结构（对线性链表无法有效地进行折半查找）。

* 以有序表表示静态查找表时，进行查找的方法除了折半查找之外，还有斐波那契查找和插值查找。

* 索引顺序表的查找：若以索引顺序表表示静态查找表，则search函数可用分块查找来实现，分块查找又称索引顺序查找。在此查找法中，除表本身外，尚需建立一个“索引表”。对每个子表（或称块）建立一个索引项，其中包括两项内容：关键字项（其值为该子表内的最大关键字）和指针项（指示该子表的第一个记录在表中位置）。索引表按关键字有序，则表或者有序或者分块有序。

***

2. 动态查找表

* 动态查找表的特点是，表结构本身是在查找过程中动态生成的，即对于给定值key，若表中存在其关键字等于key的记录，则查找成功返回，否则插入关键字等于key的记录。

```c++
//抽象数据类型动态查找表的定义如下
ADT DynamicSearchTable
{
    数据对象：
    数据关系：
    基本操作：
        InitDSTable(&DT);
    	DestroyDSTable(&DT);
    	SearchDSTable(DT, key);
    	InsertDSTable(&DT, e);
    	DeleteDSTable(&DT, key);
    	TraverseDSTable(DV, Visit());
}ADT DynamicSearchTable
```

* [**二叉排序树**](https://github.com/fantasia85/data-structure/blob/master/seventh_search/search/DynamicSearchTable/BST.cpp)（Binary Sort Tree）或者是一棵空树；或者是具有下列性质的二叉树：
  * 若它的左子树不空，则左子树上**所有**结点的值**均小于**它的根结点的值；
  * 若它的右子树不空，则右子树上**所有**结点的值**均大于**它的根结点的值；
  * 它的左、右子树也分别为二叉排序树。
* 二叉排序树的插入：新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个结点的左孩子或右孩子结点。
* 中序遍历二叉排序树可得到一个关键字的有序序列。
* 每次插入的新结点都是二叉排序树上新的叶子结点，则在进行插入操作时，不必移动其他结点，仅需改动某个结点的指针，由空变为非空即可。
* 二叉排序树的删除：假设在二叉排序树上被删结点为***p**（指向结点的指针为p），其双亲结点为***f**（结点指针为f），且不失一般性，可设***p**是***f**的左孩子。分三种情况讨论：
  * 若***p**结点为叶子结点，即左孩子和右孩子均为空树。由于删去叶子结点不破坏整棵树的结构，则只需修改其双亲结点的指针即可。
  * 若***p**结点只有左子树或者只有右子树，此时只要令左子树或右子树直接成为其双亲结点***f**的左子树即可。
  * 若***p**结点的左子树和右子树均不空。显然，此时不能如上简单处理。有两种做法：其一是令***p**的左子树为***f**的左子树，而***p**的右子树为***s**的右子树；其二是令***p**的直接前驱（或直接后继）替代***p**，然后再从二叉排序树中删去它的直接前驱（或直接后继）。
  * 直接前驱：左子树的最大值；直接后继：右子树的最小值。
* 在随机的情况下，二叉排序树的平均查找长度和log*n*是等数量级的。
* [**平衡二叉树**](https://github.com/fantasia85/data-structure/blob/master/seventh_search/search/DynamicSearchTable/BBST.cpp)（Balanced Binary Tree 或Height-Balanced Tree）又称AVL树。它或者是一棵空树，或者是具有下列性质的二叉树：它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度之差的绝对值不超过1。若将二叉树上结点的**平衡因子**BF（Balance Factor）定义为该结点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有结点的平衡因子只可能是-1，0和1。
* 一般情况下，假设由于在二叉排序树上插入结点而失去平衡的最小子树根结点的指针为a（即a是离插入结点最近，且平衡因子绝对值超过1的祖先结点），则失去平衡后进行调整的规律可归纳为下列4种情况：
  1. 单项右旋平衡处理：由于在***a**的左子树根结点的左子树上插入结点，***a**的平衡因子由1增至2，致使以***a**为根的子树失去平衡，则需进行一次向右的顺时针旋转操作。
  2. 单项左旋平衡处理：由于在***a**的右子树根结点的右子树上插入结点，***a**的平衡因子由-1变为-2，致使以***a**为根结点的子树失去平衡，则需进行一次向右的逆时针旋转操作。
  3. 双向旋转（先左后右）平衡处理：由于在***a**的左子树根结点的右子树上插入结点，***a**的平衡因子由1增至2，致使以***a**为根结点的子树失去平衡，则需进行两次旋转（先左旋后右旋）操作。
  4. 双向旋转（先右后左）平衡处理：由于在***a**的右子树根结点的左子树上插入结点，***a**的平衡因子由-1变为-2，致使以***a**为根结点的子树失去平衡，则需进行两次旋转（先右旋后左旋）操作。
* 当平衡的二叉排序树因插入结点而失去平衡时，仅需对最小不平衡子树进行平衡旋转处理即可。
* 在平衡的二叉排序树BBST上插入一个新的数据元素e的递归算法可描述如下：
  * 若BBST为空树，则插入一个数据元素为e的新结点作为BBST的根结点，树的深度增1；
  * 若e的关键字和BBST的根结点的关键字相等，则不进行插入；
  * 若e的关键字小于BBST的根结点的关键字，而且在BBST的左子树中不存在和e有相同关键字的结点，则将e插入在BBST的左子树上，并且当插入之后的左子树深度增加（+1）时，分别就下列不同情况处理之：
    1. BBST的根结点的平衡因子为-1（右子树的深度大于左子树的深度）：则将根结点的平衡因子更改为0，BBST的深度不变；
    2. BBST的根结点的平衡因子为0（左、右子树的深度相等）：则将根结点的平衡因子更改为1，BBST的深度增1；
    3. BBST的根结点的平衡因子为1（左子树的深度大于右子树的深度）：若BBST的左子树根结点的平衡因子为1，则需进行单向右旋平衡处理，并且在右旋处理之后，将根结点和其右子树根结点的平衡因子更改为0，树的深度不变；若BBST的左子树根结点的平衡因子为-1，则需进行先向左、后向右的双向旋转平衡处理，并且在旋转处理之后，修改根结点和其左、右子树根结点的平衡因子，树的深度不变；
  * 若e的关键字大于BBST的根结点的关键字，而且在BBST的右子树中不存在和e有相同关键字的结点，则将e插入在BBST的右子树上，并且当插入之后的右子树深度增加（+1）时，分别就不同情况处理之。

```c++
//平衡二叉树的类型定义
typedef struct BSTNode
{
    ElemType data;
    int bf; //结点的平衡因子
    struct BSTNode *lchild, *rchild; //左、右孩子指针
}BSTNode, *BSTree;
```

* 在平衡树上进行查找的时间复杂度为*O(logn)*。

* B-树是一种平衡的多路查找树，它在文件系统中很有用。

* 一棵m阶的B-树，或为空树，或为满足下列特征的m叉树：

  1. 树中每个结点至多有m棵子树；
  2. 若根结点不是叶子结点，则至少有两棵子树；
  3. 除根之外的所有非终端结点至少有*┍m/2┑*棵子树；
  4. 所有的非终端结点中包含下列信息数据：（n, A<sub>0</sub>, K<sub>1</sub>, A<sub>1</sub>, K<sub>2</sub>, A<sub>2</sub>, ..., K<sub>n</sub>, A<sub>n</sub>）。其中：K<sub>i</sub>为关键字，且K<sub>i</sub><K<sub>i+1</sub>(i = 1, ..., n-1)；A<sub>i</sub>(i = 0, ..., n)为指向子树根结点的指针，且指针A<sub>i</sub>所指子树中所有结点的关键字均小于K<sub>i</sub>(i = 1, ..., n)，A<sub>n</sub>所指子树中所有结点的关键字均大于K<sub>n</sub>，n(*┍m/2┑-1<=n<=m-1*)为关键字的个数（或n+1为子树个数）。
  5. 所有的叶子结点都出现在同一层次上，并且不带信息（可以看做是外部结点或查找失败的结点，实际上这些结点不存在，指向这些结点的指针为空）。

  ```c++
  //结点类型
  #define m 3  //B-树的阶，假设为3
  typedef struct BTNode
  {
      int keynum;  //结点中关键字个数，即结点的大小
      struct BTNode *parent;  //指向双亲结点
      KeyType key[m+1]; //关键字向量，0号单元未用
      struct BTNode *ptr[m+1]; //子树指针向量
      Record *recptr[m+1]; //记录指针向量，0号单元未用
  }BTNode, *BTree; //B-树结点和B-树的类型
  typedef struct
  {
      BTNode *pt;  //指向找到的结点
      int i; //1...m，在结点中的关键字序号
      int tag; //1:查找成功，0:查找失败
  }Result; //B-树的查找结果类型
  ```

* 按照B-树的定义，3阶的B-树上所有非终端结点至多可有两个关键字，至少有一个关键字（即子树个数为2或3，故又称2-3树）。

* B+树是应文件系统所需而出的一种B-树的变型树。一棵m阶的B+树和m阶的B-树的差异在于：

  1. 有n棵子树的结点中含有n个关键字；
  2. 所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序连接；
  3. 所有的非终端结点可以看成是索引部分，结点中仅含有其子树（根结点）中的最大（或最小）关键字。
  
* **键树**又称**数字查找树**（Digital Search Trees）。它是一棵度>=2的树，树中的每个结点中不是包含一个或几个关键字，而是只含有组成关键字的符号。例如，若关键字是数值，则结点中只包含一个数位，若关键字是单词，则结点中只包含一个字母字符。

* 通常，键树可有两种存储结构：

  1. 以树的孩子兄弟链表来表示键树，则每个分支结点包括3个域：symbol域：存储关键字的第一个字符；first域：存储指向第一棵子树根的指针；next域：存储指向右兄弟的指针。同时，叶子结点的infoptr域存储指向该关键字记录的指针。此时的键树又称**双链树**。

  ```c++
  //双链树的存储表示
  #define MAXKEYLEN 16  //关键字的最大长度
  typedef struct
  {
      char ch[MAXKEYLEN]; //关键字
      int num;   //关键字长度
  }KeysType; //关键字类型
  typedef enum { LEAF, BRANCH } NodeKind; //结点种类:{叶子，分支}
  typedef struct DLTNode
  {
      char symbol;  
      struct DLTNode *next;  //指向兄弟结点的指针
      NodeKind kind;
      union
      {
          Record *infoptr;  //叶子结点的记录指针
          struct DLTNode *first;  //分支结点的孩子链指针
      };
  }DLTNode, *DLTree; //双链树的类型
  ```

  2. 若以树的多重链表表示键树，则树的每个结点中应含有d个指针域，此时的键树又称Trie树。若从键树中某个结点到叶子结点的路径上每个结点都只有一个孩子，则可将该路径上所有结点压缩成一个“叶子结点”，且在该叶子结点中存储关键字及指向记录的指针等信息。由此，在Trie树中有两种结点：分支结点（含有d个指针域和一个指示该结点中非空指针域的个数的整数域）和叶子结点（含有关键字域和指向记录的指针域）。在分支结点中不设数据域，每个分支结点所表示的字符均由其双亲结点中（指示该结点）的指针所在位置决定。

  ```C++
  //Trie树的存储表示
  typedef struct TrieNode
  {
      NodeKind kind;
      union
      {
          struct {KeysType K; Record *infoptr; } lf; //叶子结点
          struct {TrieNode *ptr[27]; int num; } bh; //分支结点
      };
  }TrieNode, *TrieTree; //键树类型
  ```

***

3. **哈希表**

* 理想的情况是希望不经过任何比较，一次存取便能得到所查记录，那就必须在记录的存储位置和它的关键字之间建立一个确定的对应关系*f*，使每个关键字和结构中一个唯一的存储位置相对应。因而在查找时，只要根据这个对应关系*f*找到给定值K的像*f(K)*。若结构中存在关键字和K相等的记录，则必定在*f(K)*的存储位置上，由此，不需要进行比较便可直接取得所查记录。再次，我们称这个对应关系*f*为**哈希**（Hash）函数，按这个思想建立的表为哈希表。
* 对不同的关键字可能得到同一哈希地址，即key1≠key2，而*f(key1)=f(key2)*，这个现象称**冲突**（collision）。具有相同函数值的关键字对该哈希函数来说称做**同义词**(synonym)。
* 综上所述，可如下描述哈希表：根据设定的哈希函数*H(key)*和处理冲突的方法将一组关键字映像到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为**哈希表**，这一映像过程称为哈希造表或**散列**，所得存储位置称**哈希地址**或**散列地址**。
* 若对于关键字集合中的任一个关键字，经哈希函数映像到地址集合中任何一个地址的概率是相等的，则称此类哈希函数为**均匀的**（Uniform）哈希函数。常用的构造哈希函数的方法有：
  1. 直接定址法：取关键字或关键字的某个线性函数值为哈希地址。即*H(key)=key*或*H(key)=a·key+b*，其中a和b为常数（这种哈希函数叫做自身函数）。
  2. 数字分析法：假设关键字是以r为基的数（如：以10为基的十进制数），并且哈希表中可能出现的关键字都是事先知道的，则可取关键字的若干数位组成哈希地址。
  3. 平方取中法：取关键字平方后的中间记为为哈希地址。这是一种较常用的构造哈希函数的方法。
  4. 折叠法：将关键字分隔成位数相同的几部分（最后一部分的位数可以不同），然后取这几部分的叠加和（舍弃进位）作为哈希地址，这方法称为折叠法（folding）。
  5. 除留余数法：取关键字被某个不大于哈希表表长m的数p除后所得余数为哈希地址。即*H(key) = key MOD p, p<= m*。这是一种最简单，也最常用的构造哈希函数的方法。它不仅可以对关键字直接取模（MOD），也可在折叠、平方取中等运算之后取模。由众人的经验得知：一般情况下，可以选p为质数或不包含小于20的质因数的合数。
  6. 随机数法：选择一个随机函数，取关键字的随机函数值为它的哈希地址，即*H(key) = random(key)*，其中random为随机函数。
* 通常用的处理冲突的方法有下列几种：
  1. 开放定址法：*H<sub>i</sub> = (H(key) + d<sub>i</sub>) MOD m, i = 1, 2, ...,k(k <= m - 1)*，其中H(key)为哈希函数，m为哈希表表长，d<sub>i</sub>为增量序列，可有下列3种取法：
     * d<sub>i</sub>=1,2,3,...,m-1,称线性探测再散列；
     * d<sub>i</sub>=1<sup>2</sup>,-1<sup>2</sup>,2<sup>2</sup>,-2<sup>2</sup>,3<sup>2</sup>,...,±k<sup>2</sup>,(k <= m/2)，称二次探测再散列；
     * d<sub>i</sub>=伪随机数序列，称伪随机探测再散列。
  2. 再哈希法：*H<sub>i</sub>=RH<sub>i</sub>(key), i=1,2,...,k*，RH<sub>i</sub>均是不同的哈希函数，即在同义词产生地址冲突时计算另一个哈希函数地址，直到冲突不再发生。
  3. 链地址法：将所有关键字为同义词的记录存储在同一线性链表中。假设某哈希函数产生的哈希地址在区间[0, m-1]上，则设立一个指针型向量Chain ChainHash[m];其每个分量的初始状态都是空指针。凡哈希地址为i的记录都插入到头指针为ChainHash[i]的链表中。
  4. 建立一个公共溢出区。

```c++
//开放定址哈希表的存储结构
int hashsize[] = { 997, ... }; //哈希表容量递增表，一个合适的素数序列
typedef struct 
{
    ElemType *elem; //数据元素存储基址，动态分配数组
    int count; //当前数据元素个数
    int sizeindex; //hashsize[sizeindex]为当前容量
}HashTable; 
```

* 在哈希表上进行查找的过程和哈希造表的过程基本一致。给定K值，根据造表时设定的哈希函数求得哈希地址，若表中此位置上没有记录，则查找不成功；否则比较关键字，若和给定值相等，则查找成功；否则根据造表时设定的处理冲突的方法找“下一地址”，直至哈希表中某个位置为“空”或者表中所填记录的关键字等于给定值时为止。

* 从哈希表的查找过程可见：

  1. 虽然哈希表在关键字与记录的存储位置之间建立了直接映像，但由于“冲突“的产生，使得哈希表的查找过程仍然是一个给定值和关键字进行比较的过程。因此，仍需以平均查找长度作为衡量哈希表的查找效率的度量。
  2. 查找过程中需和给定值进行比较的关键字的个数取决于下列三个因素：哈希函数，处理冲突的方法和哈希表的装填因子。

* 哈希表的装填因子定义为：*α=表中填入的记录数/哈希表的长度*  

  *α*标志哈希表的装满程度。直观地看，*α*越小，发生冲突的可能性就越小；反之*α*越大，表中已填入的记录越多，再填记录时，发生冲突的可能性就越大，则查找时，给定值需与之进行比较的关键字的个数也就越多。