#### 8. 排序

***

* **排序**（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。
* 假设K<sub>i</sub>=K<sub>j</sub>（1<=i<=n,1<=j<=n,i≠j），且在排序前的序列中R<sub>i</sub>领先于R<sub>j</sub>（即i<=j）。若在排序后的序列中R<sub>i</sub>仍领先于R<sub>j</sub>，则称所用的**排序方法是稳定的**；反之，若可能使排序后的序列中R<sub>j</sub>领先于R<sub>i</sub>，则称所用的**排序方法是不稳定的**。
* 由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两大类：一类是**内部排序**，指的是待排序记录存放在计算机随机存储器中进行的排序过程；另一类是**外部排序**，指的是待排序记录的数量很大， 以致内存一次不能容纳全部记录，在排序过程中你尚需对外存进行访问的排序过程。
* 内部排序如果按排序过程中依据的不同原则对内部排序方法进行分类，则大致可分为插入排序、交换排序、选择排序、归并排序和计数排序等五类；如果按内部排序过程中所需的工作量来区分，则可分为3类：（1）简单的排序方法，其时间复杂度为*O(n<sup>2</sup>)*；（2）先进的排序方法，其时间复杂度为*O(nlongn)*；（3）基数排序，其时间复杂度为*O(d·n)*。
* 通常，在排序的过程中需进行下列两种基本操作：（1）比较两个关键字的大小；（2）将记录从一个位置移动至另一个位置。

```c++
//待排序的数据类型设为
#define MAXSIZE 20 //一个用做示例的小顺序表的最大长度
typedef int KeyType;  //定义关键字类型为整数类型
typedef struct
{
    KeyType key;  //关键字项
    InfoType otherinfo; //其他数据项
}RedType;  //记录类型
typedef struct
{
    RedType r[MAXSIZE + 1]; //r[0]闲置或用作哨兵单元
    int length;  //顺序表长度
}SqList;  //顺序表类型
```

***

1. **插入排序**

* **直接插入排序**（Straight Insertion Sort）是一种最简单的排序方法，它的基本操作时将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表。
* 直接插入排序的时间复杂度为*O(n<sup>2</sup>)*。
* 折半插入排序：由于插入排序的基本操作是在一个有序表中进行查找和插入，这个“查找”操作可利用“折半查找”来实现，由此进行的插入排序称之为折半插入排序（Binary Insertion Sort）。
* 折半插入排序所需附加存储空间和直接插入排序相同，从时间上比较，折半插入排序仅减少了关键字间的比较次数，而记录的移动次数不变。因此，折半插入排序的时间复杂度仍为*O(n<sup>2</sup>)*。
* **2-路插入排序**是在折半插入排序的基础上在改进之，其目的是减少排序过程中移动记录的次数，但为此需要n个记录的辅助空间。2-路插入排序只能减少移动记录的次数，而不能绝对避免移动记录。
* 若希望在排序过程中不移动记录，只有改变存储结构，进行表插入排序。
* 