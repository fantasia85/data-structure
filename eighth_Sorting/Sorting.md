#### 8. 排序

***

* **排序**（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。
* 假设K<sub>i</sub>=K<sub>j</sub>（1<=i<=n,1<=j<=n,i≠j），且在排序前的序列中R<sub>i</sub>领先于R<sub>j</sub>（即i<=j）。若在排序后的序列中R<sub>i</sub>仍领先于R<sub>j</sub>，则称所用的**排序方法是稳定的**；反之，若可能使排序后的序列中R<sub>j</sub>领先于R<sub>i</sub>，则称所用的**排序方法是不稳定的**。
* 由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两大类：一类是**内部排序**，指的是待排序记录存放在计算机随机存储器中进行的排序过程；另一类是**外部排序**，指的是待排序记录的数量很大， 以致内存一次不能容纳全部记录，在排序过程中你尚需对外存进行访问的排序过程。
* 内部排序如果按排序过程中依据的不同原则对内部排序方法进行分类，则大致可分为插入排序、交换排序、选择排序、归并排序和计数排序等五类；如果按内部排序过程中所需的工作量来区分，则可分为3类：（1）简单的排序方法，其时间复杂度为*O(n<sup>2</sup>)*；（2）先进的排序方法，其时间复杂度为*O(nlongn)*；（3）基数排序，其时间复杂度为*O(d·n)*。
* 通常，在排序的过程中需进行下列两种基本操作：（1）比较两个关键字的大小；（2）将记录从一个位置移动至另一个位置。

```c++
//待排序的数据类型设为
#define MAXSIZE 20 //一个用做示例的小顺序表的最大长度
typedef int KeyType;  //定义关键字类型为整数类型
typedef struct
{
    KeyType key;  //关键字项
    InfoType otherinfo; //其他数据项
}RedType;  //记录类型
typedef struct
{
    RedType r[MAXSIZE + 1]; //r[0]闲置或用作哨兵单元
    int length;  //顺序表长度
}SqList;  //顺序表类型
```

***

1. **插入排序**

* [**直接插入排序**](https://github.com/fantasia85/data-structure/blob/master/eighth_Sorting/Insertion_Sort/S_Insertion_Sort.cpp)（Straight Insertion Sort）是一种最简单的排序方法，它的基本操作时将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表。
* 直接插入排序的时间复杂度为*O(n<sup>2</sup>)*。
* [折半插入排序](https://github.com/fantasia85/data-structure/blob/master/eighth_Sorting/Insertion_Sort/B_Insertion_Sort.cpp)：由于插入排序的基本操作是在一个有序表中进行查找和插入，这个“查找”操作可利用“折半查找”来实现，由此进行的插入排序称之为折半插入排序（Binary Insertion Sort）。
* 折半插入排序所需附加存储空间和直接插入排序相同，从时间上比较，折半插入排序仅减少了关键字间的比较次数，而记录的移动次数不变。因此，折半插入排序的时间复杂度仍为*O(n<sup>2</sup>)*。
* **2-路插入排序**是在折半插入排序的基础上在改进之，其目的是减少排序过程中移动记录的次数，但为此需要n个记录的辅助空间。2-路插入排序只能减少移动记录的次数，而不能绝对避免移动记录。
* 若希望在排序过程中不移动记录，只有改变存储结构，进行表插入排序。
*  [表插入排序](https://github.com/fantasia85/data-structure/blob/master/eighth_Sorting/Insertion_Sort/SL_Insertion_Sort.cpp)：假设以静态链表类型作为待排记录序列的存储结构，则表插入排序的过程描述如下：首先将静态链表中数组下标为“1”的分量（结点）和表头结点构成一个循环链表，然后依次将下标为“2“至”n”的分量（结点）按记录关键字非递减有序插入到循环链表中。

```C++
//表插入排序的静态链表类型
#define SIZE 100 //静态链表容量
typedef struct
{
    RcdType rc; //记录项
    int next; //指针项
}SLNode; //表结点类型
typedef struct
{
    SLNode r[SIZE];  //0号单元为表头结点
    int length; //链表当前长度
}SLinkListType;  //静态链表类型
```

* 表插入排序的时间复杂度仍是*O(n<sup>2</sup>)*。另一方面，表插入排序的结果只是求得一个有序链表，则只能对它进行顺序查找，不能进行随机查找，为了能实现有序表的折半查找，尚需对记录进行重新排列。
* 重排记录的做法是：顺序扫描有序链表，将链表中第i个结点移动至数组的第i个分量中。
* 希尔排序（Shell's Sort）又称“缩小增量排序”（Diminishing Increment Sort），它也是一种属从插入排序类的方法，但在时间效率上较前述几种排序方法有较大的改进。它的基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。希尔排序的一个特点是：子序列的构成不是简单地“逐段分割“，而是将相隔某个”增量“的记录组成一个子序列。

***

2. 快速排序

* 这一类是藉助“交换”进行排序的方法，其中最简单的一种就是人们所熟知的**起泡排序**（Bubble Sort）。其第i趟起泡排序是从L.r[i]到L.r[n-i+1]依次比较相邻两个记录的关键字，并在“逆序”时交换相邻记录，其结果是这n-i+1个记录中关键字最大的记录被交换到第n-i+1的位置上。整个排序过程需进行k(1<=k<n)趟起泡排序，显然，判别起泡排序结束的条件应该是“在一趟排序过程中没有进行过交换记录的操作”。其总的时间复杂度为*O(n<sup>2</sup>)*。
* 

