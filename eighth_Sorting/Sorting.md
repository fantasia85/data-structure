#### 8. 排序

***

* **排序**（Sorting）是计算机程序设计中的一种重要操作，它的功能是将一个数据元素（或记录）的任意序列，重新排列成一个按关键字有序的序列。
* 假设K<sub>i</sub>=K<sub>j</sub>（1<=i<=n,1<=j<=n,i≠j），且在排序前的序列中R<sub>i</sub>领先于R<sub>j</sub>（即i<=j）。若在排序后的序列中R<sub>i</sub>仍领先于R<sub>j</sub>，则称所用的**排序方法是稳定的**；反之，若可能使排序后的序列中R<sub>j</sub>领先于R<sub>i</sub>，则称所用的**排序方法是不稳定的**。
* 由于待排序的记录数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两大类：一类是**内部排序**，指的是待排序记录存放在计算机随机存储器中进行的排序过程；另一类是**外部排序**，指的是待排序记录的数量很大， 以致内存一次不能容纳全部记录，在排序过程中你尚需对外存进行访问的排序过程。
* 内部排序如果按排序过程中依据的不同原则对内部排序方法进行分类，则大致可分为插入排序、交换排序、选择排序、归并排序和计数排序等五类；如果按内部排序过程中所需的工作量来区分，则可分为3类：（1）简单的排序方法，其时间复杂度为*O(n<sup>2</sup>)*；（2）先进的排序方法，其时间复杂度为*O(nlongn)*；（3）基数排序，其时间复杂度为*O(d·n)*。
* 通常，在排序的过程中需进行下列两种基本操作：（1）比较两个关键字的大小；（2）将记录从一个位置移动至另一个位置。

```c++
//待排序的数据类型设为
#define MAXSIZE 20 //一个用做示例的小顺序表的最大长度
typedef int KeyType;  //定义关键字类型为整数类型
typedef struct
{
    KeyType key;  //关键字项
    InfoType otherinfo; //其他数据项
}RedType;  //记录类型
typedef struct
{
    RedType r[MAXSIZE + 1]; //r[0]闲置或用作哨兵单元
    int length;  //顺序表长度
}SqList;  //顺序表类型
```

***

1. **插入排序**

* [**直接插入排序**](https://github.com/fantasia85/data-structure/blob/master/eighth_Sorting/Insertion_Sort/S_Insertion_Sort.cpp)（Straight Insertion Sort）是一种最简单的排序方法，它的基本操作时将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表。
* 直接插入排序的时间复杂度为*O(n<sup>2</sup>)*。
* [折半插入排序](https://github.com/fantasia85/data-structure/blob/master/eighth_Sorting/Insertion_Sort/B_Insertion_Sort.cpp)：由于插入排序的基本操作是在一个有序表中进行查找和插入，这个“查找”操作可利用“折半查找”来实现，由此进行的插入排序称之为折半插入排序（Binary Insertion Sort）。
* 折半插入排序所需附加存储空间和直接插入排序相同，从时间上比较，折半插入排序仅减少了关键字间的比较次数，而记录的移动次数不变。因此，折半插入排序的时间复杂度仍为*O(n<sup>2</sup>)*。
* **2-路插入排序**是在折半插入排序的基础上在改进之，其目的是减少排序过程中移动记录的次数，但为此需要n个记录的辅助空间。2-路插入排序只能减少移动记录的次数，而不能绝对避免移动记录。
* 若希望在排序过程中不移动记录，只有改变存储结构，进行表插入排序。
*  [表插入排序](https://github.com/fantasia85/data-structure/blob/master/eighth_Sorting/Insertion_Sort/SL_Insertion_Sort.cpp)：假设以静态链表类型作为待排记录序列的存储结构，则表插入排序的过程描述如下：首先将静态链表中数组下标为“1”的分量（结点）和表头结点构成一个循环链表，然后依次将下标为“2“至”n”的分量（结点）按记录关键字非递减有序插入到循环链表中。

```C++
//表插入排序的静态链表类型
#define SIZE 100 //静态链表容量
typedef struct
{
    RcdType rc; //记录项
    int next; //指针项
}SLNode; //表结点类型
typedef struct
{
    SLNode r[SIZE];  //0号单元为表头结点
    int length; //链表当前长度
}SLinkListType;  //静态链表类型
```

* 表插入排序的时间复杂度仍是*O(n<sup>2</sup>)*。另一方面，表插入排序的结果只是求得一个有序链表，则只能对它进行顺序查找，不能进行随机查找，为了能实现有序表的折半查找，尚需对记录进行重新排列。
* 重排记录的做法是：顺序扫描有序链表，将链表中第i个结点移动至数组的第i个分量中。
* 希尔排序（Shell's Sort）又称“缩小增量排序”（Diminishing Increment Sort），它也是一种属从插入排序类的方法，但在时间效率上较前述几种排序方法有较大的改进。它的基本思想是：先将整个待排记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。希尔排序的一个特点是：子序列的构成不是简单地“逐段分割“，而是将相隔某个”增量“的记录组成一个子序列。

***

2. 快速排序

* 这一类是藉助“交换”进行排序的方法，其中最简单的一种就是人们所熟知的[**起泡排序**](https://github.com/fantasia85/data-structure/blob/master/eighth_Sorting/Quick_Sort/Bubble_Sort.cpp)（Bubble Sort）。其第i趟起泡排序是从L.r[i]到L.r[n-i+1]依次比较相邻两个记录的关键字，并在“逆序”时交换相邻记录，其结果是这n-i+1个记录中关键字最大的记录被交换到第n-i+1的位置上。整个排序过程需进行k(1<=k<n)趟起泡排序，显然，判别起泡排序结束的条件应该是“在一趟排序过程中没有进行过交换记录的操作”。其总的时间复杂度为*O(n<sup>2</sup>)*。
* [**快速排序**](https://github.com/fantasia85/data-structure/blob/master/eighth_Sorting/Quick_Sort/Quick_Sort.cpp)（Quick Sort）是对起泡排序的一种改进。它的基本思想是，通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两个部分记录继续进行排序，已达到整个序列有序。
  * 首先任意选取一个记录（通常可选第一个记录）作为**枢轴**（或支点）（pivot），然后按下述原则重新排列其余记录：将所有关键字较它小的记录都安置在它的位置之前，将所有关键字较它大的记录都安置在它的位置之后。由此可以该“枢轴”记录最后所落的位置i作分界线，将序列分割成两个子序列。这个过程称做一趟快速排序（或一次划分）。
  * 一趟快速排序的具体做法是：附设两个指针low和high，它们的初值分别为low和high，设枢轴记录的关键字为pivotkey，则首先从high所指位置起向前搜索找到第一个关键字小于pivotkey的记录和枢轴记录互相交换，重复这两步直至low=high为止。
  * 快速排序被认为是，在所有同数量级（*O(nlogn)*）的排序方法中，其平均性能最好。但是，若初始记录序列按关键字有序或基本有序时，快速排序将蜕化为起泡排序，其时间复杂度为*O(n<sup>2</sup>)*。为改进之，通常依“三者取中“的法则来选取枢轴记录，采用三者取中的规则可大大改善快速排序在最坏情况下的性能。

***

3. 选择排序

* **选择排序**（Selection Sort）的基本思想是：每一趟在n-i+1(i=1,2,...,n-1)个记录中选取关键字最小的记录作为有序序列中第i个记录。
* [**简单选择排序**](https://github.com/fantasia85/data-structure/blob/master/eighth_Sorting/Selection_Sort/S_Selection_Sort.cpp)（Simple Selection Sort）：一趟简单选择排序的操作为：通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i（1<=i<=n）个记录交换之。
* 简单选择排序的时间复杂度为*O(N<sup>2</sup>)*。
* **树形选择排序**（Tree Selection Sort），又称竞标赛排序（Tournament Sort），是一种按照锦标赛的思想进行选择排序的方法。首先对n个记录的关键字进行两两比较，然后在其中┍n/2┑个较小者之间再进行两两比较，如此重复，直至选出最小关键字的记录为止。
* 树形选择排序的时间复杂度为*O(nlogn)*。
* [**堆排序**](https://github.com/fantasia85/data-structure/blob/master/eighth_Sorting/Selection_Sort/Heap_Sort.cpp)（Heap Sort）只需要一个记录大小的辅助空间，每个待排序的记录仅占有一个存储空间。堆的定义如下：n个元素的序列*{k<sub>1</sub>,k<sub>2</sub>,...,k<sub>n</sub>}*当且仅当满足下关系时，*{k<sub>i</sub><=k<sub>2i</sub>,k<sub>i</sub><=k<sub>2i+1</sub>}*或*{k<sub>i</sub>>=k<sub>2i</sub>,k<sub>i</sub>>=k<sub>2i+1</sub>}(i=1,2,..,┕n/2┙)*，称之为堆。
* 若将和此序列对应的一维数组（即以一维数组作此序列的存储结构）看成是一个完全二叉树，则堆的含义表明，完全二叉树中所有非终端结点的值均不大于（或不小于）其左、右孩子结点的值。由此，若序列是堆，则堆顶元素（或完全二叉树的根）必为序列中n个元素的最小值（或最大值）。
* 从一个无序序列建堆的过程就是一个反复“筛选“的过程。若将此序列看成是一个完全二叉树，则最后一个非终端结点是第*┕n/2┙*个元素，由此”筛选“只需从第*┕n/2┙*个元素开始。
* 堆排序在最坏的情况下，其时间复杂度也为*O(nlogn)*。相对于快速排序来说，这是堆排序的最大优点。此外，堆排序仅需一个记录大小共交换用的存储空间。

***

4. 归并排序

* **归并排序**（Merging Sort）：“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。
* [2-路归并排序](https://github.com/fantasia85/data-structure/blob/master/eighth_Sorting/Merging_Sort/mergingsort.cpp)中的核心操作时将一维数组中前后相邻的两个有序序列归并为一个有序序列。
* 实现归并排序需要和待排记录等数量的辅助空间，其时间复杂度为*O(nlogn)*。
* 与快速排序和堆排序相比，归并排序的最大特点是，它是一种稳定的排序方法。

***

5. 基数排序

* **基数排序**（Radix Sorting）是和前面所述各类排序方法完全不相同的一种排序方法。基数排序是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。
* 基数排序的两种方法：最高位优先（Most Significant Digit first）法，简称MSD法；最低位优先（Least Significant Digit first）法，简称LSD法。
* 对于n个记录（假设每个记录含d个关键字，每个关键字的取值范围为rd个值）进行链式基数排序的时间复杂度为*O(d(n+rd))*，其中每一趟分配的时间复杂度为*O(n)*，每一趟收集的时间复杂度为*O(rd)*，整个排序需进行d趟分配和收集。

***

#### 各种排序方法总结

| 排序方法 |      平均时间      |      最坏情况      | 辅助存储  |
| :------: | :----------------: | :----------------: | :-------: |
| 简单排序 | *O(n<sup>2</sup>)* | *O(n<sup>2</sup>)* |  *O(1)*   |
| 快速排序 |     *O(nlogn)*     | *O(n<sup>2</sup>)* | *O(logn)* |
|  堆排序  |     *O(nlogn)*     |     *O(nlogn)*     |  *O(1)*   |
| 归并排序 |     *O(nlogn)*     |     *O(nlogn)*     |  *O(n)*   |
| 基数排序 |    *O(d(n+rd))*    |    *O(d(n+rd))*    |  *O(rd)*  |

1. 从平均时间性能而言，快速排序最佳，其所需时间最省，但快速排序在最坏情况下的时间性能不如堆排序和归并排序。而后两者相比较的结果是，在n较大时，归并排序所需时间较堆排序省，但它所需的辅助存储量最多。
2. 表中的”简单排序“包括除希尔排序之外的所有插入排序，起泡排序和简单选择排序，其中以直接插入排序为最简单，当序列中的记录”基本有序“或n值较小时，它是最佳的排序方法，因此常将它和其他的排序方法，诸如快速排序、归并排序等结合在一起使用。
3. 基数排序的时间复杂度也可写成*O(d·n)*。因此，它最适用于n值很大而关键字较小的序列。若关键字也很大，而序列中大多数记录的“最高位关键字”均不同，则亦可先按“最高位关键字”不同将序列分成若干“小”的子序列，而后进行直接插入排序。
4. 从方法的稳定性来比较，基数排序是稳定的内排方法，所有时间复杂度为*O(n<sup>2</sup>)*的简单排序法也是稳定的，然而，快速排序、堆排序和希尔排序等时间性能较好的排序方法都是不稳定的。一般来说，排序过程中的“比较”是在“相邻的两个记录关键字”间进行的排序方法是稳定的。

* 借助于“比较”进行排序的算法在最坏情况下能达到的最好的时间复杂度为*O(nlogn)*。

